================================================================================
TÓPICO II - RESOLUÇÃO DOS PROBLEMAS
Justificativa Algorítmica para cada Análise
================================================================================

I. ROTEAMENTO COM MENOR CUSTO
================================================================================

Problema:
Encontrar a rota de menor custo entre dois pontos da rede logística, considerando
a distância/peso das arestas.

Algoritmo Utilizado: DIJKSTRA

Justificativa:
-----------
1. NATUREZA DO PROBLEMA:
   - Grafo com pesos não-negativos
   - Necessidade de encontrar caminho mínimo entre dois vértices
   - Grafo direcionado (rotas têm direção específica)

2. POR QUE DIJKSTRA?
   - Complexidade O((V + E) log V) com heap - eficiente para grafos grandes
   - Garante solução ótima para pesos não-negativos
   - Mais eficiente que Bellman-Ford (O(VE)) para este caso
   - Mais eficiente que busca em amplitude simples

3. ALTERNATIVAS CONSIDERADAS:
   - Bellman-Ford: Menos eficiente, mas lidaria com pesos negativos (não necessário)
   - BFS Simples: Apenas para pesos unitários (não aplicável)
   - Floyd-Warshall: Para todos os pares (overhead desnecessário)

4. IMPLEMENTAÇÃO:
   - Inicializar distâncias com infinito, exceto origem
   - Usar fila de prioridade para seleção eficiente do próximo vértice
   - Relaxar arestas iterativamente
   - Reconstruir caminho através do dicionário de predecessores

Resultado Esperado: Caminho com menor custo total de A para B

---

II. CAPACIDADE MÁXIMA DE ESCOAMENTO
================================================================================

Problema:
Determinar o fluxo máximo que pode ser transportado da origem ao destino,
considerando a capacidade de cada aresta (ligação).

Algoritmo Utilizado: EDMONDS-KARP (Ford-Fulkerson com BFS)

Justificativa:
-----------
1. NATUREZA DO PROBLEMA:
   - Grafo de fluxo com capacidades nas arestas
   - Encontrar fluxo máximo de origem para sumidouro
   - Identificar gargalos (corte mínimo)

2. POR QUE EDMONDS-KARP?
   - Implementação de Ford-Fulkerson usando BFS
   - Complexidade garantida O(VE²) - muito melhor que Ford-Fulkerson puro
   - Garante encontrar fluxo máximo e corte mínimo
   - Algoritmo determinístico (sem ciclos infinitos)

3. ALTERNATIVAS CONSIDERADAS:
   - Push-Relabel: Mais eficiente O(V³) ou O(V²√E), mas complexo
   - Dinic's Algorithm: O(V²E), ligeiramente menos eficiente que Edmonds-Karp
   - Ford-Fulkerson puro: Pode ter performance ruim ou ciclos infinitos

4. VANTAGEM ADICIONAL:
   - Identifica CORTE MÍNIMO automaticamente após convergência
   - Corte mínimo = arestas críticas cuja remoção reduz fluxo a zero
   - Essencial para identificar gargalos na rede

5. IMPLEMENTAÇÃO:
   - Manter grafo residual com capacidades diretas e reversas
   - Usar BFS para encontrar caminhos aumentantes
   - Calcular gargalo (menor capacidade) no caminho
   - Atualizar capacidades residuais
   - Repetir até não haver caminhos aumentantes

Resultado Esperado: Fluxo máximo e lista de arestas do corte mínimo

---

III. EXPANSÃO DA REDE DE COMUNICAÇÃO (ÁRVORE GERADORA MÍNIMA)
================================================================================

Problema:
Conectar todos os hubs de comunicação com o menor custo total de cabos/ligações,
sem criar ciclos desnecessários.

Algoritmos Utilizados: KRUSKAL e PRIM

Justificativa Kruskal:
-----------
1. NATUREZA DO PROBLEMA:
   - Encontrar árvore geradora mínima (AGM)
   - Grafo não-direcionado com pesos nas arestas
   - Objetivo: conectar V vértices com V-1 arestas de menor custo

2. POR QUE KRUSKAL?
   - Complexidade O(E log E) - eficiente para grafos esparsos
   - Abordagem gulosa: ordena arestas por peso crescente
   - Usa Union-Find para detectar ciclos em O(α(V)) amortizado
   - Mais intuitivo para grafos esparsos

3. COMO FUNCIONA:
   - Ordenar todas as arestas por peso
   - Para cada aresta (em ordem):
     * Se conecta dois componentes diferentes: adicionar à AGM
     * Senão: descartar (criaria ciclo)
   - Parar quando tiver V-1 arestas

Justificativa Prim:
-----------
1. POR QUE PRIM?
   - Complexidade O(V² + E) ou O((V + E) log V) com heap
   - Melhor para grafos densos
   - Abordagem incremental: expande árvore a partir de um vértice
   - Garante componente conexo desde o início

2. COMO FUNCIONA:
   - Começar com um vértice arbitrário
   - Repetidamente adicionar aresta mínima que conecta árvore a fora
   - Expandir até incluir todos os V vértices

3. SELEÇÃO:
   - Projeto: usa Kruskal se densidade ≤ 0.5, Prim senão
   - Ambos garantem MESMA solução ótima (apenas ordem diferente)

Resultado Esperado: AGM com V-1 arestas e custo total mínimo

---

IV. AGENDAMENTO DE MANUTENÇÕES SEM CONFLITO
================================================================================

Problema:
Agendar manutenções de rotas em turnos, garantindo que rotas que compartilham
recursos (oficinas, pátios, equipamentos) não sejam mantidas simultaneamente.

Algoritmo Utilizado: WELSH-POWELL (Coloração de Grafo)

Justificativa:
-----------
1. NATUREZA DO PROBLEMA:
   - Grafo de conflitos: vértices = rotas, arestas = conflito de recursos
   - Encontrar coloração com número mínimo de cores
   - Cada cor representa um turno/dia

2. POR QUE WELSH-POWELL?
   - Problema NP-completo, mas heurística gulosa funciona bem
   - Complexidade O(V²) - viável para grafos com 100+ vértices
   - Garante solução aceitável (não necessariamente ótima)
   - Simples de implementar e entender

3. COMO FUNCIONA:
   - Ordenar vértices por grau DECRESCENTE (Welsh-Powell específico)
   - Para cada vértice (em ordem):
     * Colorir com menor cor não-usada por vizinhos adjacentes
     * Procurar outros vértices não-adjacentes para mesma cor

4. VANTAGEM DA ORDEM:
   - Vértices com muitos conflitos (alto grau) são processados primeiro
   - Reduz chance de precisar cores adicionais
   - Heurística muito eficaz na prática

5. ALTERNATIVAS:
   - Algoritmo guloso simples: O(V²) mas menos eficiente
   - Busca exaustiva: O(2^V) impraticável
   - Simulated Annealing: mais eficiente mas não determinístico

Resultado Esperado: Número mínimo de turnos + alocação de rotas por turno

---

V. ROTA ÚNICA DE INSPEÇÃO
================================================================================

Problema A - Percurso de Rotas:
Inspecionar TODAS as rotas (arestas) exatamente uma vez, retornando ao início.

Algoritmo: CIRCUITO EULERIANO + HIERHOLZER

Justificativa:
-----------
1. CONDIÇÃO NECESSÁRIA E SUFICIENTE:
   - Todos os vértices devem ter grau PAR
   - Se 0 vértices ímpares: circuito Euleriano existe
   - Se 2 vértices ímpares: caminho Euleriano existe
   - Senão: nenhum percurso possível

2. ALGORITMO HIERHOLZER:
   - Complexidade O(V + E) - extremamente eficiente
   - Usa pilha para rastrear caminhos
   - Garante encontrar circuito quando existe

3. IMPLEMENTAÇÃO:
   - Verificar graus de todos os vértices
   - Se todos pares: usar Hierholzer
   - Hierholzer: começar em vértice, seguir arestas removendo
   - Quando ficar preso, fazer backtrack

Resultado Esperado A: Sequência de vértices visitando cada aresta uma vez

---

Problema B - Percurso de Hubs:
Visitar TODOS os hubs (vértices) exatamente uma vez, retornando ao início.

Algoritmo: CIRCUITO HAMILTONIANO + DFS COM BACKTRACKING

Justificativa:
-----------
1. NATUREZA DO PROBLEMA:
   - Problema NP-completo (sem polinômio conhecimento)
   - Sem condição simples de existência (como Euler)
   - Requer busca combinatorial

2. POR QUE DFS COM BACKTRACKING?
   - Mais simples para grafos pequenos/médios
   - Garante encontrar solução se existir
   - Pode ser acelerado com pruning

3. LIMITAÇÕES:
   - Complexidade até O(V!) no pior caso
   - Impraticável para V > ~15 sem otimizações
   - Para grafos com 50+ vértices: heurísticas necessárias

4. ALTERNATIVAS:
   - Nearest Neighbor: O(V²) heurística, não exata
   - Held-Karp: O(2^V * V²) dinâmica, melhor que força bruta
   - Simulated Annealing: heurística meta-heurística

Resultado Esperado B: Sequência de vértices visitando cada um exatamente uma vez,
                      ou confirmação que não existe circuito

---

RESUMO FINAL
================================================================================

Algoritmo              | Tipo       | Complexidade    | Problema
-----------------------|------------|-----------------|---------------------------
Dijkstra               | Caminho    | O((V+E) log V)  | Roteamento mínimo
Edmonds-Karp           | Fluxo      | O(VE²)          | Capacidade máxima
Kruskal/Prim           | AGM        | O(E log E)/O(V²)| Expansão rede
Welsh-Powell           | Coloração  | O(V²)           | Agendamento turnos
Hierholzer             | Euleriano  | O(V+E)          | Inspeção rotas
DFS Backtracking       | Hamiltoniano| O(V!)          | Inspeção hubs

Todos os algoritmos escolhidos são:
✓ Teoricamente fundamentados
✓ Comprovadamente eficientes para o tamanho do problema
✓ Implementação prática viável
✓ Produzem soluções ótimas (exceto Welsh-Powell e DFS Hamiltoniano em alguns casos)

================================================================================

